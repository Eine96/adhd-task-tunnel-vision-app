<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>任务隧道视野</title>
    <meta name="theme-color" content="#f8fafc">
    
    <!-- PWA 配置 -->
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">


    <!-- 引入Vue.js和Tailwind CSS -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }

        /* --- 全新动画设计 --- */

        /* 1. 深度切换动画 (代替左右滑动) */
        .depth-forward-enter-active,
        .depth-forward-leave-active,
        .depth-backward-enter-active,
        .depth-backward-leave-active {
            transition: transform 0.4s cubic-bezier(0.45, 0, 0.55, 1), opacity 0.4s ease;
        }

        .depth-forward-enter-from { transform: scale(1.1); opacity: 0; }
        .depth-forward-leave-to { transform: scale(0.9); opacity: 0; }
        
        .depth-backward-enter-from { transform: scale(0.9); opacity: 0; }
        .depth-backward-leave-to { transform: scale(1.1); opacity: 0; }

        /* 2. 专注文本翻转动画 */
        .flip-enter-active { transition: all 0.4s ease; transform-style: preserve-3d; }
        .flip-leave-active { transition: all 0.2s ease; transform-style: preserve-3d; }
        .flip-enter-from { transform: translateY(30px) rotateX(-90deg); opacity: 0; }
        .flip-leave-to { transform: translateY(-30px) rotateX(90deg); opacity: 0; }

        /* 3. 列表交错动画 */
        .stagger-list-move,
        .stagger-list-enter-active,
        .stagger-list-leave-active { transition: all 0.4s ease; }
        .stagger-list-enter-from,
        .stagger-list-leave-to { opacity: 0; transform: translateY(20px); }
        .stagger-list-leave-active { position: absolute; }


        /* 4. 弹簧式弹窗动画 */
        .spring-modal-enter-active .modal-box { animation: spring-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .spring-modal-leave-active .modal-box { animation: spring-out 0.3s ease; }
        .spring-modal-enter-active, .spring-modal-leave-active { transition: background-color 0.3s ease; }
        .spring-modal-enter-from, .spring-modal-leave-to { background-color: rgba(0,0,0,0); }
        
        @keyframes spring-in {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes spring-out {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(0.9); opacity: 0; }
        }

        /* 5. 能量波奖励动画 */
        @keyframes ripple-out {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        .reward-ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(16, 185, 129, 0.3);
            transform: scale(0);
            animation: ripple-out 0.6s ease-out forwards;
            pointer-events: none;
        }

        /* 6. 五彩纸屑动画 */
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--color);
            top: 0;
            animation: confetti-fall var(--duration) var(--delay) linear forwards;
            pointer-events: none;
        }
        .all-done-content {
            animation: pop-in 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
            opacity: 0;
            transform: scale(0.9);
        }
        @keyframes pop-in {
            to { opacity: 1; transform: scale(1); }
        }
        .all-done-fade-out {
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }


        /* --- 其他动画和样式 (部分保留和调整) --- */
        @keyframes countdown-pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.5; } 100% { transform: scale(1); opacity: 1; } }
        .countdown-pulse { animation: countdown-pulse 0.6s ease-in-out infinite; }
        @keyframes breathing { 0%, 100% { transform: scale(1); box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05); } 50% { transform: scale(1.03); box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1); } }
        .breathing-button { animation: breathing 2.5s ease-in-out infinite; }
        
        .sortable-ghost { opacity: 0 !important; }
        .sortable-chosen { box-shadow: 0 10px 20px rgba(0,0,0,0.2); transform: scale(1.02); }

        .task-card-wrapper {
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        }
        .task-card-actions {
            position: absolute;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
        }
        .task-card-actions.left { left: 0; }
        .task-card-actions.right { right: 0; }

        .task-card-content {
            touch-action: pan-y;
            position: relative;
            z-index: 10;
            background-color: white;
            transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            overflow: hidden;
        }
        
        /* --- 能量填充效果 --- */
        .long-press-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0; /* 由JS控制 */
            background: radial-gradient(circle at center left, rgba(26, 179, 135, 0.5), rgba(79, 70, 229, 0.3));
            z-index: 5;
            transition: width 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            opacity: 0;
        }
        
        .long-press-active .long-press-fill {
            opacity: 1;
        }
        
        @keyframes card-pulse {
             0%, 100% { transform: scale(1); }
             50% { transform: scale(1.02); }
        }
        
        .long-press-active {
            animation: card-pulse 0.8s ease-in-out infinite;
            box-shadow: 0 10px 20px rgba(79, 70, 229, 0.2);
        }

        @keyframes particle-burst {
            0% {
                transform: scale(1) translate(0, 0);
                opacity: 1;
            }
            100% {
                transform: scale(0) translate(var(--x), var(--y));
                opacity: 0;
            }
        }

        .fill-particle {
            position: absolute;
            top: 50%;
            left: 0;
            width: 6px;
            height: 6px;
            background-color: var(--color);
            border-radius: 50%;
            pointer-events: none;
            animation: particle-burst 0.6s ease-out forwards;
            z-index: 6;
        }

        .reorder-handle {
            cursor: grab;
        }
        
        @keyframes peek-a-boo {
            0%, 100% { transform: translateX(0); }
            50% { transform: translateX(-4px); }
        }
        .swipe-affordance-icon {
            animation: peek-a-boo 1.5s 1s ease-in-out infinite;
        }

        .checkmark__circle { stroke-dasharray: 166; stroke-dashoffset: 166; stroke-width: 2; stroke-miterlimit: 10; stroke: #10b981; fill: none; animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards; }
        .checkmark { width: 100px; height: 100px; border-radius: 50%; display: block; stroke-width: 3; stroke: #fff; stroke-miterlimit: 10; margin: 0 auto; box-shadow: inset 0px 0px 0px #10b981; animation: fill .4s ease-in-out .4s forwards, scale .3s ease-in-out .9s both; }
        .checkmark__check { transform-origin: 50% 50%; stroke-dasharray: 48; stroke-dashoffset: 48; animation: stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards; }
        @keyframes stroke { 100% { stroke-dashoffset: 0; } }
        @keyframes scale { 0%, 100% { transform: none; } 50% { transform: scale3d(1.1, 1.1, 1); } }
        @keyframes fill { 100% { box-shadow: inset 0px 0px 0px 50px #10b981; } }

        /* PWA 更新提示样式 */
        #update-toast {
            transform: translateY(200%);
            transition: transform 0.4s ease-in-out;
        }
        #update-toast.show {
            transform: translateY(0);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="app" class="w-full max-w-sm h-[85vh] max-h-[800px] mx-auto bg-white rounded-3xl shadow-lg flex flex-col relative overflow-hidden [perspective:1000px]">
    </div>

    <!-- PWA 更新提示UI -->
    <div id="update-toast" class="fixed bottom-4 right-4 z-50 bg-slate-800 text-white p-4 rounded-lg shadow-lg flex items-center gap-4">
        <p>发现新版本！</p>
        <button id="update-button" class="px-4 py-1 bg-indigo-500 rounded-md hover:bg-indigo-600">刷新</button>
    </div>


    <script type="module">
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, nextTick, watch } = Vue;

        // --- 组件定义 (此处省略所有组件定义代码，与之前版本相同) ---

        // 1. 启动画面组件
        const SplashScreen = {
            template: `
                <div @click="$emit('enter')" class="h-full flex flex-col items-center justify-center text-center p-4 text-slate-500 cursor-pointer">
                    <div class="relative w-48 h-48">
                        <div class="absolute inset-0 rounded-full bg-indigo-600"></div>
                        <div class="absolute inset-4 rounded-full bg-indigo-500"></div>
                        <div class="absolute inset-8 rounded-full bg-indigo-400"></div>
                        <div class="absolute inset-12 rounded-full bg-white flex items-center justify-center">
                            <svg class="w-16 h-16 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>
                        </div>
                    </div>
                    <h2 class="text-xl font-bold text-slate-700 mt-8">看不见山高路远</h2>
                    <p class="mt-1">只专注于下一步。</p>
                </div>
            `
        };

        // 2. 任务卡片子组件
        const TaskCard = {
            props: ['task', 'swipedState', 'mode', 'isSelected'],
            emits: ['start', 'edit', 'delete', 'swipe', 'toggle-select'],
            setup(props, { emit }) {
                const cardContent = ref(null);
                const cardWrapper = ref(null);
                const fillElement = ref(null);
                const pressProgress = ref(0);
                let pressStartTime = 0;
                let animationFrameId = null;
                const LONG_PRESS_DURATION = 800;
                const PARTICLE_COLORS = ['#fde047', '#67e8f9', '#86efac', '#fca5a5'];
                let lastParticleTime = 0;

                const gesture = reactive({
                    startX: 0, startY: 0,
                    isDragging: false,
                    isPressing: false,
                });

                const onPointerDown = (e) => {
                    if (props.mode !== 'default' || e.button === 2) return;
                    
                    gesture.startX = e.clientX || e.touches[0].clientX;
                    gesture.startY = e.clientY || e.touches[0].clientY;
                    gesture.isPressing = true;
                    pressStartTime = Date.now();

                    if(cardWrapper.value) cardWrapper.value.classList.add('long-press-active');
                    
                    animationFrameId = requestAnimationFrame(updatePressProgress);

                    document.addEventListener('mousemove', onPointerMove);
                    document.addEventListener('mouseup', onPointerUp);
                    document.addEventListener('touchmove', onPointerMove, { passive: false });
                    document.addEventListener('touchend', onPointerUp);
                };

                const createParticle = (progress) => {
                    const particle = document.createElement('div');
                    particle.className = 'fill-particle';
                    const color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                    const x = (Math.random() * 100 + 50) * (Math.random() > 0.5 ? 1 : -1);
                    const y = (Math.random() * 100 + 50) * (Math.random() > 0.5 ? 1 : -1);
                    
                    particle.style.setProperty('--color', color);
                    particle.style.setProperty('--x', `${x}px`);
                    particle.style.setProperty('--y', `${y}px`);
                    
                    particle.style.left = `${progress}%`;
                    
                    if(fillElement.value) fillElement.value.appendChild(particle);
                    setTimeout(() => particle.remove(), 600);
                };

                const updatePressProgress = () => {
                    if (!gesture.isPressing) return;
                    const elapsed = Date.now() - pressStartTime;
                    const progress = Math.min(elapsed / LONG_PRESS_DURATION, 1);
                    pressProgress.value = progress * 100;

                    if (elapsed > lastParticleTime + 50) {
                        createParticle(pressProgress.value);
                        lastParticleTime = elapsed;
                    }

                    if (progress >= 1) {
                        emit('start', props.task.id);
                        if (navigator.vibrate) navigator.vibrate(50);
                        resetGesture();
                    } else {
                        animationFrameId = requestAnimationFrame(updatePressProgress);
                    }
                };

                const onPointerMove = (e) => {
                    if (!gesture.isPressing && !gesture.isDragging) return;

                    const currentX = e.clientX || e.touches[0].clientX;
                    const currentY = e.clientY || e.touches[0].clientY;
                    const diffX = currentX - gesture.startX;
                    const diffY = currentY - gesture.startY;

                    if (!gesture.isDragging) {
                        if (Math.abs(diffX) > 20 && Math.abs(diffX) > Math.abs(diffY)) {
                            gesture.isDragging = true;
                            gesture.isPressing = false; // Cancel press
                            cancelAnimationFrame(animationFrameId);
                            pressProgress.value = 0;
                            if(cardWrapper.value) cardWrapper.value.classList.remove('long-press-active');
                            emit('swipe', { id: props.task.id, state: null });
                        } else if (Math.abs(diffY) > 10) {
                            // Allow vertical scroll
                            resetGesture();
                            return;
                        } else {
                            // Not a swipe yet, let long press continue
                            return;
                        }
                    }
                    
                    if (gesture.isDragging) {
                        e.preventDefault();
                        let newX = diffX;
                        if (props.swipedState === 'left') newX -= 72;
                        if (props.swipedState === 'right') newX += 72;
                        
                        const clampedX = Math.max(-72, Math.min(72, newX));

                        cardContent.value.style.transition = 'none';
                        cardContent.value.style.transform = `translateX(${clampedX}px)`;
                    }
                };

                const onPointerUp = (e) => {
                    if (gesture.isDragging) {
                        const currentTransform = new DOMMatrix(getComputedStyle(cardContent.value).transform).m41;
                        cardContent.value.style.transition = 'transform 0.3s ease';
                        if (currentTransform < -36) {
                            cardContent.value.style.transform = 'translateX(-72px)';
                            emit('swipe', { id: props.task.id, state: 'left' });
                        } else if (currentTransform > 36) {
                            cardContent.value.style.transform = 'translateX(72px)';
                            emit('swipe', { id: props.task.id, state: 'right' });
                        } else {
                            cardContent.value.style.transform = 'translateX(0px)';
                            emit('swipe', { id: null, state: null });
                        }
                    }
                    resetGesture();
                };

                const resetGesture = () => {
                    if(cardWrapper.value) cardWrapper.value.classList.remove('long-press-active');
                    gesture.isPressing = false;
                    gesture.isDragging = false;
                    pressProgress.value = 0;
                    cancelAnimationFrame(animationFrameId);
                    document.removeEventListener('mousemove', onPointerMove);
                    document.removeEventListener('mouseup', onPointerUp);
                    document.removeEventListener('touchmove', onPointerMove);
                    document.removeEventListener('touchend', onPointerUp);
                };
                
                watch(() => props.swipedState, (state) => {
                    if (cardContent.value) {
                        cardContent.value.style.transition = 'transform 0.3s ease';
                        if (state === 'left') cardContent.value.style.transform = 'translateX(-72px)';
                        else if (state === 'right') cardContent.value.style.transform = 'translateX(72px)';
                        else cardContent.value.style.transform = 'translateX(0px)';
                    }
                });

                return { cardContent, cardWrapper, fillElement, pressProgress, onPointerDown };
            },
            template: `
                <div class="task-card-wrapper" ref="cardWrapper">
                    <div class="task-card-actions left">
                        <button @click="$emit('delete', task.id)" class="bg-rose-500 text-white w-[72px] h-full flex items-center justify-center">删除</button>
                    </div>
                    <div class="task-card-actions right">
                        <button @click="$emit('edit', task)" class="bg-indigo-500 text-white w-[72px] h-full flex items-center justify-center">编辑</button>
                    </div>
                    <div 
                        ref="cardContent"
                        class="task-card-content p-4 border flex items-center justify-between"
                        @mousedown="onPointerDown"
                        @touchstart="onPointerDown"
                    >
                        <div v-if="mode === 'select'" class="mr-4">
                            <input type="checkbox" :checked="isSelected" @change="$emit('toggle-select', task.id)" class="w-5 h-5 rounded-full text-indigo-600 focus:ring-indigo-500">
                        </div>
                        <div v-if="mode === 'reorder'" class="reorder-handle mr-4 text-slate-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg>
                        </div>
                        <div class="long-press-fill" ref="fillElement" :style="{ width: pressProgress + '%' }"></div>
                        <div class="relative z-10 flex-grow">
                            <span class="font-semibold text-slate-700">{{ task.name }}</span>
                            <p class="text-xs text-slate-400">{{ task.subtasks.length }} 个步骤</p>
                        </div>
                        <svg v-if="mode === 'default'" xmlns="http://www.w3.org/2000/svg" class="relative z-10 h-6 w-6 text-slate-400 swipe-affordance-icon" fill="none" viewBox="0 0 24 24" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" /></svg>
                    </div>
                </div>
            `
        };

        // 3. 仪表盘主界面
        const DashboardScreen = {
            components: { TaskCard },
            props: ['tasks'],
            emits: ['create-task', 'start-task', 'edit-task', 'delete-task', 'update-order', 'delete-multiple', 'archive-multiple', 'view-archive'],
            setup(props, { emit }) {
                const taskListEl = ref(null);
                const swipedCardId = ref(null);
                const swipedCardState = ref(null);
                const isMenuOpen = ref(false);
                const mode = ref('default'); // 'default', 'reorder', 'select'
                const selectedTasks = ref(new Set());
                let sortable = null;

                const handleSwipe = ({ id, state }) => {
                    swipedCardId.value = id;
                    swipedCardState.value = state;
                };

                const enterReorderMode = () => {
                    mode.value = 'reorder';
                    isMenuOpen.value = false;
                    nextTick(initSortable);
                };

                const enterSelectMode = () => {
                    mode.value = 'select';
                    isMenuOpen.value = false;
                };

                const exitEditModes = () => {
                    mode.value = 'default';
                    selectedTasks.value.clear();
                    if (sortable) {
                        sortable.destroy();
                        sortable = null;
                    }
                };
                
                const toggleSelectTask = (taskId) => {
                    if (selectedTasks.value.has(taskId)) {
                        selectedTasks.value.delete(taskId);
                    } else {
                        selectedTasks.value.add(taskId);
                    }
                };

                const deleteSelected = () => {
                    emit('delete-multiple', Array.from(selectedTasks.value));
                    exitEditModes();
                };

                const archiveSelected = () => {
                    emit('archive-multiple', Array.from(selectedTasks.value));
                    exitEditModes();
                };

                const initSortable = () => {
                    if (sortable) sortable.destroy();
                    if (taskListEl.value && mode.value === 'reorder') {
                         sortable = new Sortable(taskListEl.value, {
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            handle: '.reorder-handle',
                            onEnd: (evt) => {
                                emit('update-order', { oldIndex: evt.oldIndex, newIndex: evt.newIndex });
                            }
                        });
                    }
                }
                
                const beforeEnter = (el) => {
                    el.style.opacity = 0;
                    el.style.transform = 'translateY(20px)';
                }
                const enter = (el, done) => {
                    const delay = el.dataset.index * 50;
                    setTimeout(() => {
                        el.style.transition = 'all 0.4s ease';
                        el.style.opacity = 1;
                        el.style.transform = 'translateY(0)';
                        done();
                    }, delay);
                }

                watch(mode, (newMode) => {
                    if (newMode !== 'reorder' && sortable) {
                        sortable.destroy();
                        sortable = null;
                    }
                });

                return { taskListEl, swipedCardId, swipedCardState, isMenuOpen, mode, selectedTasks, handleSwipe, enterReorderMode, enterSelectMode, exitEditModes, toggleSelectTask, deleteSelected, archiveSelected, beforeEnter, enter };
            },
            template: `
                <div class="p-5 flex flex-col h-full" @click="handleSwipe({id: null, state: null}); isMenuOpen = false;">
                    <!-- Header -->
                    <header class="flex justify-between items-center pt-1 pb-4">
                        <div v-if="mode === 'default'">
                            <h1 class="text-3xl font-black text-slate-800">任务隧道</h1>
                        </div>
                        <div v-if="mode === 'reorder'">
                            <h1 class="text-xl font-bold text-slate-800">排序任务</h1>
                        </div>
                         <div v-if="mode === 'select'">
                            <h1 class="text-xl font-bold text-slate-800">{{ selectedTasks.size > 0 ? \`已选择 \${selectedTasks.size} 项\` : '选择任务' }}</h1>
                        </div>

                        <div v-if="mode === 'default'" class="relative">
                            <button @click.stop="isMenuOpen = !isMenuOpen" class="p-2 rounded-full hover:bg-slate-100">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" /></svg>
                            </button>
                            <div v-if="isMenuOpen" @click.stop="isMenuOpen = false" class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-xl z-20 py-1">
                                <a href="#" @click.prevent="enterReorderMode" class="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100">排序任务</a>
                                <a href="#" @click.prevent="enterSelectMode" class="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100">批量管理</a>
                                <a href="#" @click.prevent="$emit('view-archive')" class="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100">查看归档</a>
                            </div>
                        </div>
                         <button v-if="mode !== 'default'" @click="exitEditModes" class="px-4 py-1.5 rounded-full font-semibold bg-slate-200 hover:bg-slate-300 text-slate-800">
                           {{ mode === 'reorder' ? '完成' : '取消' }}
                         </button>
                    </header>

                    <!-- Task List -->
                    <div v-if="tasks.length === 0" class="h-full flex flex-col items-center justify-center text-center p-4 text-slate-500">
                         <h2 class="text-2xl font-bold text-slate-700 mt-8">你的任务列表是空的</h2>
                         <p class="mt-2 max-w-xs">点击下方的按钮来创建你的第一个任务流吧。</p>
                    </div>
                    <div v-else ref="taskListEl" class="flex-grow overflow-y-auto px-2 space-y-3">
                        <transition-group @before-enter="beforeEnter" @enter="enter">
                            <task-card 
                                v-for="(task, index) in tasks" 
                                :key="task.id" 
                                :data-index="index"
                                :task="task"
                                :swipedState="swipedCardId === task.id ? swipedCardState : null"
                                :mode="mode"
                                :isSelected="selectedTasks.has(task.id)"
                                @start="$emit('start-task', $event)"
                                @edit="$emit('edit-task', $event)"
                                @delete="$emit('delete-task', $event)"
                                @swipe="handleSwipe"
                                @toggle-select="toggleSelectTask"
                            />
                        </transition-group>
                    </div>

                    <!-- Footer -->
                    <div class="p-4 mt-auto">
                        <transition name="depth-forward">
                        <div v-if="mode === 'select'" class="flex justify-center gap-4">
                             <button @click="archiveSelected" :disabled="selectedTasks.size === 0" class="px-6 py-3 rounded-lg font-semibold text-slate-700 bg-slate-200 hover:bg-slate-300 disabled:opacity-50">归档</button>
                             <button @click="deleteSelected" :disabled="selectedTasks.size === 0" class="px-6 py-3 rounded-lg font-semibold text-white bg-rose-500 hover:bg-rose-600 disabled:opacity-50">删除</button>
                        </div>
                        <button v-else @click.stop="$emit('create-task')" class="w-full bg-indigo-600 text-white rounded-xl py-4 text-lg font-semibold flex items-center justify-center hover:bg-indigo-700 transition-colors shadow-lg" :class="{'breathing-button': tasks.length === 0}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg>
                            创建新任务流
                        </button>
                        </transition>
                    </div>
                </div>
            `
        };

        // 4. 任务编辑器界面
        const EditorScreen = {
            props: ['taskToEdit'],
            emits: ['save', 'back'],
            setup(props, { emit }) {
                const taskName = ref('');
                const subtasks = ref([]);
                const subtaskListEl = ref(null);
                let sortable = null;
                let nextSubId = 0;

                const editorTitle = computed(() => props.taskToEdit ? '编辑任务' : '新建任务');

                const initialize = () => {
                    nextSubId = 0;
                    if (props.taskToEdit) {
                        taskName.value = props.taskToEdit.name;
                        subtasks.value = JSON.parse(JSON.stringify(props.taskToEdit.subtasks)).map(sub => ({
                            ...sub,
                            id: `sub-${nextSubId++}`
                        }));
                    } else {
                        taskName.value = '';
                        subtasks.value = [];
                    }
                };
                
                onMounted(() => {
                    initialize();
                    if (subtaskListEl.value) {
                        sortable = new Sortable(subtaskListEl.value.$el, {
                            animation: 150,
                            handle: '.drag-handle',
                            ghostClass: 'sortable-ghost',
                            onEnd: (evt) => {
                                const item = subtasks.value.splice(evt.oldIndex, 1)[0];
                                subtasks.value.splice(evt.newIndex, 0, item);
                            }
                        });
                    }
                });
                
                watch(() => props.taskToEdit, initialize);

                const addSubtask = async () => {
                    subtasks.value.push({ id: `sub-${nextSubId++}`, text: '' });
                    await nextTick();
                    const inputs = document.querySelectorAll('.edit-input');
                    const lastInput = inputs[inputs.length - 1];
                    if(lastInput) lastInput.focus();
                };

                const removeSubtask = (index) => {
                    subtasks.value.splice(index, 1);
                };

                const saveTask = () => {
                    if (!taskName.value.trim()) { alert('请为任务命名'); return; }
                    const finalSubtasks = subtasks.value
                        .filter(s => s.text.trim() !== '')
                        .map(s => ({ text: s.text }));

                    if (finalSubtasks.length === 0) { alert('请至少添加一个步骤'); return; }

                    const savedTask = {
                        id: props.taskToEdit ? props.taskToEdit.id : Date.now(),
                        name: taskName.value.trim(),
                        subtasks: finalSubtasks
                    };
                    emit('save', savedTask);
                };

                return { taskName, subtasks, editorTitle, addSubtask, removeSubtask, saveTask, subtaskListEl };
            },
            template: `
                <div class="p-5 flex flex-col h-full">
                    <header class="flex justify-between items-center mb-4">
                        <button @click="$emit('back')" class="text-slate-500 hover:text-slate-800">&larr; 返回</button>
                        <h2 class="text-xl font-bold text-slate-800">{{ editorTitle }}</h2>
                        <button @click="saveTask" class="bg-emerald-500 text-white px-4 py-1.5 rounded-full font-semibold hover:bg-emerald-600">完成</button>
                    </header>
                    <input type="text" v-model="taskName" placeholder="为任务命名" class="w-full p-3 mb-4 border-2 border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-600 focus:border-indigo-600">
                    <div class="flex-grow overflow-y-auto bg-slate-50 p-2 rounded-lg">
                        <transition-group name="stagger-list" tag="div" class="space-y-2" ref="subtaskListEl">
                            <div v-for="(sub, index) in subtasks" :key="sub.id" class="subtask-item flex items-center bg-white py-3 px-2 rounded-md">
                                <span class="drag-handle text-slate-400 mr-3">☰</span>
                                <input type="text" v-model="sub.text" class="edit-input flex-grow bg-white p-0 m-0 border-none focus:ring-0 outline-none" placeholder="步骤描述...">
                                <button @click="removeSubtask(index)" class="delete-subtask-btn text-rose-500 hover:text-rose-600 font-bold px-2 ml-2">×</button>
                            </div>
                        </transition-group>
                        <div @click="addSubtask" class="mt-2 flex items-center justify-center bg-transparent p-2 rounded-md border-2 border-dashed border-slate-300 hover:bg-slate-100 cursor-pointer">
                            <span class="text-slate-500 font-semibold">+ 添加步骤</span>
                        </div>
                    </div>
                </div>
            `
        };
        
        // 5. 准备开始界面
        const GetReadyScreen = {
            props: ['taskName'],
            emits: ['countdown-finished'],
            setup(props, { emit }) {
                const countdown = ref(3);
                const countdownText = computed(() => {
                    if (countdown.value > 0) return countdown.value;
                    if (countdown.value === 0) return 'Go!';
                    return '';
                });

                onMounted(() => {
                    const interval = setInterval(() => {
                        countdown.value--;
                        if (countdown.value < 0) {
                            clearInterval(interval);
                            emit('countdown-finished');
                        }
                    }, 600);
                });

                return { countdownText };
            },
            template: `
                <div class="p-5 flex flex-col h-full justify-center items-center text-center">
                    <div>
                        <p class="text-slate-500 mb-2">准备开始：</p>
                        <h2 class="text-4xl font-bold text-slate-800 mb-12">{{ taskName }}</h2>
                        <p class="text-9xl font-black text-indigo-600 countdown-pulse">{{ countdownText }}</p>
                    </div>
                </div>
            `
        };

        // 6. 专注模式界面
        const FocusScreen = {
            props: ['task'],
            emits: ['exit'],
            setup(props, { emit }) {
                const currentIndex = ref(0);
                const progressBarEl = ref(null);
                const pressStartTime = ref(0);
                const ripples = ref([]);
                const isButtonPressed = ref(false);
                let animationFrameId = null;
                
                const pressProgress = ref(0);
                const fillElement = ref(null);
                const PRESS_DURATION = 800;
                const PARTICLE_COLORS = ['#fde047', '#67e8f9', '#86efac', '#fca5a5'];
                let lastParticleTime = 0;

                const ICONS = {
                    NEXT: `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>`,
                    DONE: `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>`
                };

                const currentSubtask = computed(() => props.task.subtasks[currentIndex.value]);
                const isLastStep = computed(() => currentIndex.value === props.task.subtasks.length - 1);
                const nextButtonIcon = computed(() => isLastStep.value ? ICONS.DONE : ICONS.NEXT);
                const iconClass = computed(() => pressProgress.value > 50 ? 'text-white' : 'text-slate-800');

                const triggerRewardAnimation = () => {
                    const newRipple = { id: Date.now() };
                    ripples.value.push(newRipple);
                    setTimeout(() => {
                        ripples.value.shift();
                    }, 600);
                };

                const createParticle = (progress) => {
                    if (!fillElement.value) return;
                    const particle = document.createElement('div');
                    particle.className = 'fill-particle';
                    const color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                    const x = (Math.random() * 100 + 50) * (Math.random() > 0.5 ? 1 : -1);
                    const y = (Math.random() * 100 + 50) * (Math.random() > 0.5 ? 1 : -1);
                    
                    particle.style.setProperty('--color', color);
                    particle.style.setProperty('--x', `${x}px`);
                    particle.style.setProperty('--y', `${y}px`);
                    particle.style.left = `${progress}%`;
                    
                    fillElement.value.appendChild(particle);
                    setTimeout(() => particle.remove(), 600);
                };

                const handleNextStep = () => {
                    triggerRewardAnimation();
                    if (isLastStep.value) {
                        emit('exit', true);
                        return;
                    }
                    currentIndex.value++;
                };

                const updatePressProgress = () => {
                    if (!isButtonPressed.value) return;
                    const elapsed = Date.now() - pressStartTime.value;
                    const progress = Math.min(elapsed / PRESS_DURATION, 1);
                    
                    pressProgress.value = progress * 100;

                    if (progressBarEl.value) {
                        const segment = progressBarEl.value.children[currentIndex.value];
                        if (segment) {
                            segment.style.background = `linear-gradient(to right, #10b981 ${progress * 100}%, #e2e8f0 ${progress * 100}%)`;
                        }
                    }

                    if (elapsed > lastParticleTime + 50) {
                        createParticle(pressProgress.value);
                        lastParticleTime = elapsed;
                    }

                    if (progress >= 1) {
                        handleNextStep();
                        cancelAnimationFrame(animationFrameId);
                    } else {
                        animationFrameId = requestAnimationFrame(updatePressProgress);
                    }
                };

                const startPress = (e) => {
                    e.preventDefault();
                    isButtonPressed.value = true;
                    pressStartTime.value = Date.now();
                    lastParticleTime = 0;
                    animationFrameId = requestAnimationFrame(updatePressProgress);
                };

                const endPress = (e) => {
                    e.preventDefault();
                    isButtonPressed.value = false;
                    cancelAnimationFrame(animationFrameId);
                    
                    if (progressBarEl.value) {
                        const segment = progressBarEl.value.children[currentIndex.value];
                        if (segment) segment.style.background = '';
                    }
                    
                    pressProgress.value = 0;
                };

                const goToStep = (index) => {
                    if (index < currentIndex.value) {
                        currentIndex.value = index;
                    }
                };
                
                watch(currentIndex, (newIndex, oldIndex) => {
                    if (progressBarEl.value) {
                        const oldSegment = progressBarEl.value.children[oldIndex];
                        if (oldSegment) oldSegment.style.background = '#10b981';
                    }
                });

                return { currentIndex, currentSubtask, nextButtonIcon, iconClass, progressBarEl, ripples, isButtonPressed, startPress, endPress, goToStep, pressProgress, fillElement };
            },
            template: `
                <div class="p-5 flex flex-col h-full justify-between">
                    <header class="flex justify-start">
                         <button @click="$emit('exit', false)" class="text-slate-400 hover:text-slate-600">&larr; 退出</button>
                    </header>
                    <div class="flex-grow flex items-center justify-center overflow-hidden relative [transform-style:preserve-3d]">
                         <transition name="flip" mode="out-in">
                            <p :key="currentIndex" class="text-4xl font-bold text-center text-slate-800 break-words">{{ currentSubtask.text }}</p>
                         </transition>
                    </div>
                    <div class="w-full">
                        <div class="flex justify-center items-center mb-6">
                            <div 
                                class="relative w-48 h-20 rounded-full overflow-hidden shadow-lg border-2 border-slate-200 bg-white cursor-pointer transition-transform" 
                                :class="{'scale-95': isButtonPressed}" 
                                @mousedown="startPress" @mouseup="endPress" @mouseleave="endPress" @touchstart.prevent="startPress" @touchend.prevent="endPress"
                            >
                                <!-- Reward Ripples Container -->
                                <div class="absolute inset-0 flex items-center justify-center">
                                    <div v-for="ripple in ripples" :key="ripple.id" class="reward-ripple"></div>
                                </div>
                                <!-- Fill Layer -->
                                <div 
                                    ref="fillElement" 
                                    class="absolute top-0 left-0 h-full"
                                    style="background: radial-gradient(circle at center left, rgba(26, 179, 135, 0.7), rgba(79, 70, 229, 0.5)); transition: width 0.1s linear;"
                                    :style="{ width: pressProgress + '%' }"
                                >
                                </div>
                                <!-- Icon Layer -->
                                <div class="absolute inset-0 flex items-center justify-center pointer-events-none transition-colors duration-300" :class="iconClass" v-html="nextButtonIcon"></div>
                            </div>
                        </div>
                        <div ref="progressBarEl" class="w-full h-4 flex items-stretch gap-2">
                            <div 
                                v-for="(subtask, index) in task.subtasks" 
                                :key="index"
                                @click="goToStep(index)"
                                class="h-full rounded-md transition-all duration-500"
                                :class="[index < currentIndex ? 'bg-emerald-500' : 'bg-slate-200', index < currentIndex ? 'cursor-pointer hover:bg-emerald-600' : '']"
                                :style="{ flexGrow: 1 }"
                            ></div>
                        </div>
                    </div>
                </div>
            `
        };

        // 7. 全部完成界面
        const AllDoneScreen = {
            props: ['taskName'],
            emits: ['back-to-dash'],
            setup(props, { emit }) {
                const confettis = ref([]);
                const isButtonPressed = ref(false);
                const pressProgress = ref(0);
                const fillElement = ref(null);
                const isCompleted = ref(false);
                const encouragement = ref('');
                const isFadingOut = ref(false);
                
                let pressStartTime = 0;
                let animationFrameId = null;
                const PRESS_DURATION = 1500;
                const PARTICLE_COLORS = ['#fde047', '#67e8f9', '#f9a8d4', '#86efac', '#fca5a5', '#a78bfa'];
                let lastParticleTime = 0;

                const ENCOURAGEMENTS = [
                    '太棒了，你做到了！',
                    '为你骄傲！',
                    '看，专注起来也没那么难。',
                    '又完成了一项，继续加油！',
                    '了不起的成就！',
                    '感受一下这份成就感！'
                ];

                const createParticle = (progress) => {
                    if (!fillElement.value) return;
                    const particle = document.createElement('div');
                    particle.className = 'fill-particle';
                    const color = PARTICLE_COLORS[Math.floor(Math.random() * PARTICLE_COLORS.length)];
                    const x = (Math.random() * 150 + 50) * (Math.random() > 0.5 ? 1 : -1);
                    const y = (Math.random() * 150 + 50) * (Math.random() > 0.5 ? 1 : -1);
                    
                    particle.style.setProperty('--color', color);
                    particle.style.setProperty('--x', `${x}px`);
                    particle.style.setProperty('--y', `${y}px`);
                    particle.style.left = `50%`; // From center
                    particle.style.top = `50%`;
                    
                    fillElement.value.appendChild(particle);
                    setTimeout(() => particle.remove(), 800);
                };
                
                const handleCompletion = () => {
                    isCompleted.value = true;
                    if (navigator.vibrate) navigator.vibrate([100, 30, 100]);
                    
                    const newConfettis = [];
                    const colors = ['#fde047', '#67e8f9', '#f9a8d4', '#86efac', '#fca5a5', '#a78bfa'];
                    for (let i = 0; i < 100; i++) {
                        newConfettis.push({
                            id: `confetti-${i}`,
                            style: {
                                '--color': colors[Math.floor(Math.random() * colors.length)],
                                '--duration': `${Math.random() * 2 + 3}s`,
                                '--delay': `${Math.random() * 1}s`,
                                left: `${Math.random() * 100}vw`,
                            }
                        });
                    }
                    confettis.value = newConfettis;

                    setTimeout(() => {
                        isFadingOut.value = true;
                    }, 2000);

                    setTimeout(() => {
                        emit('back-to-dash');
                    }, 2500);
                };

                const updatePressProgress = () => {
                    if (!isButtonPressed.value) return;
                    const elapsed = Date.now() - pressStartTime;
                    const progress = Math.min(elapsed / PRESS_DURATION, 1);
                    
                    pressProgress.value = progress * 100;

                    if (elapsed > lastParticleTime + 40) {
                        createParticle(pressProgress.value);
                        lastParticleTime = elapsed;
                    }

                    if (progress >= 1) {
                        handleCompletion();
                        cancelAnimationFrame(animationFrameId);
                    } else {
                        animationFrameId = requestAnimationFrame(updatePressProgress);
                    }
                };

                const startPress = (e) => {
                    if (isCompleted.value) return;
                    e.preventDefault();
                    isButtonPressed.value = true;
                    pressStartTime = Date.now();
                    lastParticleTime = 0;
                    animationFrameId = requestAnimationFrame(updatePressProgress);
                };

                const endPress = (e) => {
                    if (isCompleted.value) return;
                    e.preventDefault();
                    isButtonPressed.value = false;
                    cancelAnimationFrame(animationFrameId);
                    pressProgress.value = 0;
                };

                onMounted(() => {
                   encouragement.value = ENCOURAGEMENTS[Math.floor(Math.random() * ENCOURAGEMENTS.length)];
                });

                return { confettis, isButtonPressed, pressProgress, fillElement, isCompleted, encouragement, isFadingOut, startPress, endPress };
            },
            template: `
                <div 
                    class="p-5 flex flex-col h-full justify-center items-center text-center overflow-hidden all-done-content"
                    :class="{ 'all-done-fade-out': isFadingOut }"
                >
                    <div class="absolute inset-0 pointer-events-none">
                        <div v-for="c in confettis" :key="c.id" class="confetti" :style="c.style"></div>
                    </div>
                    
                    <transition name="flip">
                        <div v-if="!isCompleted">
                            <h2 class="text-3xl font-bold text-slate-800 mb-2">{{ encouragement }}</h2>
                            <p class="text-lg text-slate-500 mb-12">“{{ taskName }}” 已完成！</p>
                        </div>
                    </transition>

                    <div 
                        class="relative w-48 h-48 rounded-full overflow-hidden shadow-2xl bg-white cursor-pointer transition-all duration-500 ease-in-out" 
                        :class="{ 'scale-95': isButtonPressed && !isCompleted, 'scale-110 !rounded-full !bg-emerald-400': isCompleted }"
                        @mousedown="startPress" @mouseup="endPress" @mouseleave="endPress" @touchstart.prevent="startPress" @touchend.prevent="endPress"
                    >
                        <!-- Fill Layer -->
                        <div 
                            ref="fillElement" 
                            class="absolute top-0 left-0 h-full w-full origin-center transition-transform duration-200 ease-linear"
                            :style="{ 
                                background: 'radial-gradient(circle at center, rgba(26, 179, 135, 0.7), rgba(79, 70, 229, 0.5))',
                                transform: 'scale(' + (pressProgress / 100) + ')',
                                borderRadius: '50%'
                            }"
                        >
                        </div>
                        <!-- Icon Layer -->
                        <div class="absolute inset-0 flex items-center justify-center pointer-events-none transition-opacity duration-300" :class="{'opacity-0': isCompleted}">
                             <span class="text-slate-600 font-semibold">长按完成</span>
                        </div>
                         <!-- Checkmark -->
                        <div v-if="isCompleted" class="absolute inset-0 flex items-center justify-center">
                             <svg class="checkmark !w-24 !h-24 !m-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                                <circle class="checkmark__circle !stroke-white" cx="26" cy="26" r="25" fill="none"/>
                                <path class="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                            </svg>
                        </div>
                    </div>
                </div>
            `
        };
        
        // 8. 自定义确认弹窗
        const ConfirmModal = {
            props: ['visible', 'text'],
            emits: ['confirm', 'cancel'],
            template: `
                <transition name="spring-modal">
                    <div v-if="visible" class="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
                        <div class="modal-box bg-white p-6 rounded-2xl w-[90%] max-w-xs text-center shadow-xl">
                            <p class="text-lg text-slate-800 mb-6">{{ text }}</p>
                            <div class="flex justify-center gap-4">
                                <button @click="$emit('cancel')" class="px-6 py-2 rounded-lg bg-slate-200 text-slate-700 hover:bg-slate-300">取消</button>
                                <button @click="$emit('confirm')" class="px-6 py-2 rounded-lg bg-rose-500 text-white hover:bg-rose-600">删除</button>
                            </div>
                        </div>
                    </div>
                </transition>
            `
        };

        // 9. 归档任务界面
        const ArchiveScreen = {
            props: ['archivedTasks'],
            emits: ['back', 'restore-multiple', 'delete-multiple'],
            setup(props, { emit }) {
                const selectedTasks = ref(new Set());

                const toggleSelectTask = (taskId) => {
                    if (selectedTasks.value.has(taskId)) {
                        selectedTasks.value.delete(taskId);
                    } else {
                        selectedTasks.value.add(taskId);
                    }
                };

                const restoreSelected = () => {
                    emit('restore-multiple', Array.from(selectedTasks.value));
                    selectedTasks.value.clear();
                };

                const deleteSelected = () => {
                    emit('delete-multiple', Array.from(selectedTasks.value));
                    selectedTasks.value.clear();
                };

                return { selectedTasks, toggleSelectTask, restoreSelected, deleteSelected };
            },
            template: `
                <div class="p-5 flex flex-col h-full">
                    <header class="flex justify-between items-center pt-1 pb-4">
                        <button @click="$emit('back')" class="text-slate-500 hover:text-slate-800">&larr; 返回</button>
                        <h1 class="text-xl font-bold text-slate-800">{{ selectedTasks.size > 0 ? \`已选择 \${selectedTasks.size} 项\` : '归档任务' }}</h1>
                        <div class="w-12"></div>
                    </header>
                    
                    <div v-if="archivedTasks.length === 0" class="h-full flex flex-col items-center justify-center text-center p-4 text-slate-500">
                         <h2 class="text-2xl font-bold text-slate-700 mt-8">归档列表是空的</h2>
                         <p class="mt-2 max-w-xs">这里会存放您归档的任务。</p>
                    </div>
                    <div v-else class="flex-grow overflow-y-auto px-2 space-y-3">
                        <div v-for="task in archivedTasks" :key="task.id" 
                             class="flex items-center bg-white p-4 rounded-xl border"
                             @click="toggleSelectTask(task.id)">
                            <input type="checkbox" :checked="selectedTasks.has(task.id)" class="w-5 h-5 rounded-full text-indigo-600 focus:ring-indigo-500 mr-4">
                            <div>
                                <span class="font-semibold text-slate-700">{{ task.name }}</span>
                                <p class="text-xs text-slate-400">{{ task.subtasks.length }} 个步骤</p>
                            </div>
                        </div>
                    </div>

                    <div class="p-4 mt-auto">
                        <div class="flex justify-center gap-4">
                             <button @click="restoreSelected" :disabled="selectedTasks.size === 0" class="px-6 py-3 rounded-lg font-semibold text-slate-700 bg-slate-200 hover:bg-slate-300 disabled:opacity-50">恢复</button>
                             <button @click="deleteSelected" :disabled="selectedTasks.size === 0" class="px-6 py-3 rounded-lg font-semibold text-white bg-rose-500 hover:bg-rose-600 disabled:opacity-50">删除</button>
                        </div>
                    </div>
                </div>
            `
        };


        // --- 根组件 (App) ---
        const App = {
            components: { SplashScreen, DashboardScreen, EditorScreen, GetReadyScreen, FocusScreen, AllDoneScreen, ConfirmModal, ArchiveScreen },
            setup() {
                // --- State ---
                const tasks = ref([]);
                const archivedTasks = ref([]);
                const currentView = ref('splash'); 
                const viewDirection = ref('forward');
                const activeTask = ref(null);
                const confirmModalState = reactive({
                    visible: false,
                    text: '',
                    onConfirm: null
                });

                // --- Data Persistence ---
                const loadTasks = () => {
                    const tasksJSON = localStorage.getItem('adhdTasksVue');
                    const archivedJSON = localStorage.getItem('adhdArchivedTasksVue');
                    tasks.value = tasksJSON ? JSON.parse(tasksJSON) : [];
                    archivedTasks.value = archivedJSON ? JSON.parse(archivedJSON) : [];
                };
                const saveTasks = () => {
                    localStorage.setItem('adhdTasksVue', JSON.stringify(tasks.value));
                    localStorage.setItem('adhdArchivedTasksVue', JSON.stringify(archivedTasks.value));
                };
                
                onMounted(loadTasks);

                // --- View Navigation ---
                const navigate = (view, direction = 'forward', task = null) => {
                    viewDirection.value = direction;
                    activeTask.value = task;
                    currentView.value = view;
                    if (view === 'dashboard' && !sessionStorage.getItem('hasSeenSplashVue')) {
                         sessionStorage.setItem('hasSeenSplashVue', 'true');
                    }
                };

                // --- Event Handlers ---
                const handleCreateTask = () => navigate('editor', 'forward');
                const handleEditTask = (task) => navigate('editor', 'forward', task);
                const handleSaveTask = (savedTask) => {
                    const index = tasks.value.findIndex(t => t.id === savedTask.id);
                    if (index > -1) {
                        tasks.value[index] = savedTask;
                    } else {
                        tasks.value.push(savedTask);
                    }
                    saveTasks();
                    navigate('dashboard', 'backward');
                };
                
                const showDeleteConfirm = (taskId, isMultiple = false, fromArchive = false) => {
                    const taskIds = Array.isArray(taskId) ? taskId : [taskId];
                    confirmModalState.text = isMultiple ? `你确定要永久删除这 ${taskIds.length} 个任务吗？` : '你确定要永久删除这个任务吗？';
                    confirmModalState.onConfirm = () => {
                        const idsToDelete = new Set(taskIds);
                        if (fromArchive) {
                            archivedTasks.value = archivedTasks.value.filter(t => !idsToDelete.has(t.id));
                        } else {
                            tasks.value = tasks.value.filter(t => !idsToDelete.has(t.id));
                        }
                        saveTasks();
                        confirmModalState.visible = false;
                    };
                    confirmModalState.visible = true;
                };

                const handleStartTask = (taskId) => {
                    const task = tasks.value.find(t => t.id === taskId);
                    if (task) navigate('get-ready', 'forward', task);
                };
                
                const handleFocusExit = (completed) => {
                    if (completed) {
                        navigate('all-done', 'forward', activeTask.value);
                    } else {
                        navigate('dashboard', 'backward');
                    }
                };

                const handleUpdateTaskOrder = ({ oldIndex, newIndex }) => {
                    const movedItem = tasks.value.splice(oldIndex, 1)[0];
                    tasks.value.splice(newIndex, 0, movedItem);
                    saveTasks();
                };

                const handleDeleteMultiple = (taskIds) => {
                    showDeleteConfirm(taskIds, true, currentView.value === 'archive');
                };

                const handleArchiveMultiple = (taskIds) => {
                    const idsToArchive = new Set(taskIds);
                    const tasksToArchive = tasks.value.filter(t => idsToArchive.has(t.id));
                    archivedTasks.value.push(...tasksToArchive);
                    tasks.value = tasks.value.filter(t => !idsToArchive.has(t.id));
                    saveTasks();
                };

                const handleRestoreMultiple = (taskIds) => {
                    const idsToRestore = new Set(taskIds);
                    const tasksToRestore = archivedTasks.value.filter(t => idsToRestore.has(t.id));
                    tasks.value.push(...tasksToRestore);
                    archivedTasks.value = archivedTasks.value.filter(t => !idsToRestore.has(t.id));
                    saveTasks();
                };

                return {
                    tasks,
                    archivedTasks,
                    currentView,
                    viewDirection,
                    activeTask,
                    confirmModalState,
                    navigate,
                    handleCreateTask,
                    handleEditTask,
                    handleSaveTask,
                    showDeleteConfirm,
                    handleStartTask,
                    handleFocusExit,
                    handleUpdateTaskOrder,
                    handleDeleteMultiple,
                    handleArchiveMultiple,
                    handleRestoreMultiple
                };
            },
            template: `
                <transition :name="'depth-' + viewDirection">
                    <component 
                        :is="currentView + '-screen'"
                        :key="currentView"
                        class="absolute inset-0"
                        :tasks="tasks"
                        :archivedTasks="archivedTasks"
                        :task="activeTask"
                        :taskToEdit="activeTask"
                        :taskName="activeTask?.name"
                        @enter="navigate('dashboard')"
                        @create-task="handleCreateTask"
                        @edit-task="handleEditTask"
                        @delete-task="showDeleteConfirm($event)"
                        @save="handleSaveTask"
                        @back="navigate('dashboard', 'backward')"
                        @start-task="handleStartTask"
                        @countdown-finished="navigate('focus', 'forward', activeTask)"
                        @exit="handleFocusExit"
                        @back-to-dash="navigate('dashboard', 'backward')"
                        @update-order="handleUpdateTaskOrder"
                        @delete-multiple="handleDeleteMultiple"
                        @archive-multiple="handleArchiveMultiple"
                        @view-archive="navigate('archive', 'forward')"
                        @restore-multiple="handleRestoreMultiple"
                    />
                </transition>

                <confirm-modal
                    :visible="confirmModalState.visible"
                    :text="confirmModalState.text"
                    @confirm="confirmModalState.onConfirm"
                    @cancel="confirmModalState.visible = false"
                />
            `
        };

        // --- 创建并挂载应用 ---
        const app = createApp(App);
        app.component('splash-screen', SplashScreen);
        app.component('dashboard-screen', DashboardScreen);
        app.component('editor-screen', EditorScreen);
        app.component('get-ready-screen', GetReadyScreen);
        app.component('focus-screen', FocusScreen);
        app.component('all-done-screen', AllDoneScreen);
        app.component('archive-screen', ArchiveScreen);
        app.mount('#app');


        // --- PWA Service Worker 注册和更新逻辑 ---
        if ('serviceWorker' in navigator) {
            let newWorker;
            
            navigator.serviceWorker.register('/sw.js').then(reg => {
                reg.addEventListener('updatefound', () => {
                    // 发现一个正在安装的新的 service worker
                    newWorker = reg.installing;
                    newWorker.addEventListener('statechange', () => {
                        // service worker 的状态改变
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            // 新的 service worker 已经安装但还未激活
                            // 这时我们可以提示用户有新版本可用
                            const updateToast = document.getElementById('update-toast');
                            updateToast.classList.add('show');
                        }
                    });
                });
            });

            const updateButton = document.getElementById('update-button');
            updateButton.addEventListener('click', () => {
                newWorker.postMessage({ action: 'skipWaiting' });
                const updateToast = document.getElementById('update-toast');
                updateToast.classList.remove('show');
            });

            let refreshing;
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                if (refreshing) return;
                window.location.reload();
                refreshing = true;
            });
        }

    </script>
</body>
</html>
