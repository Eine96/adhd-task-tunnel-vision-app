<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>任务隧道视野 (Vue动画重构版)</title>
    <meta name="theme-color" content="#f8fafc">

    <!-- 引入Vue.js和Tailwind CSS -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }

        /* --- 全新动画设计 --- */

        /* 1. 深度切换动画 (代替左右滑动) */
        .depth-forward-enter-active,
        .depth-forward-leave-active,
        .depth-backward-enter-active,
        .depth-backward-leave-active {
            transition: transform 0.4s cubic-bezier(0.45, 0, 0.55, 1), opacity 0.4s ease;
        }

        .depth-forward-enter-from { transform: scale(1.1); opacity: 0; }
        .depth-forward-leave-to { transform: scale(0.9); opacity: 0; }
        
        .depth-backward-enter-from { transform: scale(0.9); opacity: 0; }
        .depth-backward-leave-to { transform: scale(1.1); opacity: 0; }

        /* 2. 专注文本翻转动画 */
        .flip-enter-active { transition: all 0.4s ease; transform-style: preserve-3d; }
        .flip-leave-active { transition: all 0.2s ease; transform-style: preserve-3d; }
        .flip-enter-from { transform: translateY(30px) rotateX(-90deg); opacity: 0; }
        .flip-leave-to { transform: translateY(-30px) rotateX(90deg); opacity: 0; }

        /* 3. 列表交错动画 */
        .stagger-list-enter-active,
        .stagger-list-leave-active { transition: all 0.4s ease; }
        .stagger-list-enter-from,
        .stagger-list-leave-to { opacity: 0; transform: translateY(20px); }
        /* JS中会为每个item动态添加 transition-delay */

        /* 4. 弹簧式弹窗动画 */
        .spring-modal-enter-active .modal-box { animation: spring-in 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); }
        .spring-modal-leave-active .modal-box { animation: spring-out 0.3s ease; }
        .spring-modal-enter-active, .spring-modal-leave-active { transition: background-color 0.3s ease; }
        .spring-modal-enter-from, .spring-modal-leave-to { background-color: rgba(0,0,0,0); }
        
        @keyframes spring-in {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes spring-out {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(0.9); opacity: 0; }
        }

        /* 5. 粒子奖励动画 */
        @keyframes sparkle-effect {
            0% { transform: scale(0.8); opacity: 1; }
            100% { transform: scale(1.5) translate(var(--tx), var(--ty)); opacity: 0; }
        }
        .sparkle {
            position: absolute;
            background-color: var(--color);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: sparkle-effect 0.6s ease-out forwards;
            pointer-events: none;
        }

        /* 6. 五彩纸屑动画 */
        @keyframes confetti-fall {
            0% { transform: translateY(-10vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--color);
            top: 0;
            animation: confetti-fall var(--duration) var(--delay) linear forwards;
            pointer-events: none;
        }
        .all-done-content {
            animation: pop-in 0.5s 0.5s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
            opacity: 0;
            transform: scale(0.9);
        }
        @keyframes pop-in {
            to { opacity: 1; transform: scale(1); }
        }


        /* --- 其他动画和样式 (部分保留和调整) --- */
        @keyframes countdown-pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.5; } 100% { transform: scale(1); opacity: 1; } }
        .countdown-pulse { animation: countdown-pulse 0.4s ease-in-out infinite; }
        @keyframes breathing { 0%, 100% { transform: scale(1); box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.05), 0 4px 6px -4px rgb(0 0 0 / 0.05); } 50% { transform: scale(1.03); box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1); } }
        .breathing-button { animation: breathing 2.5s ease-in-out infinite; }
        
        /* FIX: Hide SortableJS ghost element */
        .sortable-ghost {
            opacity: 0 !important;
        }

        .task-card-wrapper {
            position: relative;
            user-select: none;
            -webkit-user-select: none;
        }
        .task-card-actions {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
        }
        /* FIX: Add spring animation for action buttons */
        @keyframes action-spring-in {
            0% { transform: scale(0.5); }
            80% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .task-card-actions button {
            transform: scale(0);
        }
        .is-swiped .task-card-actions button:nth-child(1) {
            animation: action-spring-in 0.3s 0.1s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }
        .is-swiped .task-card-actions button:nth-child(2) {
            animation: action-spring-in 0.3s 0.15s cubic-bezier(0.25, 0.8, 0.25, 1) forwards;
        }

        .task-card-content {
            touch-action: pan-y;
            position: relative;
            z-index: 10;
            background-color: white;
            transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        /* FIX: Add pressing state for physical feedback */
        .task-card-content.is-pressing {
            transform: scale(0.98);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .long-press-fill {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background-color: rgba(79, 70, 229, 0.2);
            border-radius: 0.75rem;
            z-index: 5;
            transition: width 0.1s linear;
        }
        .checkmark__circle { stroke-dasharray: 166; stroke-dashoffset: 166; stroke-width: 2; stroke-miterlimit: 10; stroke: #10b981; fill: none; animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards; }
        .checkmark { width: 100px; height: 100px; border-radius: 50%; display: block; stroke-width: 3; stroke: #fff; stroke-miterlimit: 10; margin: 10% auto; box-shadow: inset 0px 0px 0px #10b981; animation: fill .4s ease-in-out .4s forwards, scale .3s ease-in-out .9s both; }
        .checkmark__check { transform-origin: 50% 50%; stroke-dasharray: 48; stroke-dashoffset: 48; animation: stroke 0.3s cubic-bezier(0.65, 0, 0.45, 1) 0.8s forwards; }
        @keyframes stroke { 100% { stroke-dashoffset: 0; } }
        @keyframes scale { 0%, 100% { transform: none; } 50% { transform: scale3d(1.1, 1.1, 1); } }
        @keyframes fill { 100% { box-shadow: inset 0px 0px 0px 50px #10b981; } }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="app" class="w-full max-w-sm h-[85vh] max-h-[800px] mx-auto bg-white rounded-3xl shadow-lg flex flex-col relative overflow-hidden [perspective:1000px]">
    </div>

    <script type="module">
        const { createApp, ref, reactive, computed, onMounted, onUnmounted, nextTick, watch } = Vue;

        // --- 组件定义 ---

        // 1. 启动画面组件
        const SplashScreen = {
            template: `
                <div @click="$emit('enter')" class="h-full flex flex-col items-center justify-center text-center p-4 text-slate-500 cursor-pointer">
                    <div class="relative w-48 h-48">
                        <div class="absolute inset-0 rounded-full bg-indigo-600"></div>
                        <div class="absolute inset-4 rounded-full bg-indigo-500"></div>
                        <div class="absolute inset-8 rounded-full bg-indigo-400"></div>
                        <div class="absolute inset-12 rounded-full bg-white flex items-center justify-center">
                            <svg class="w-16 h-16 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" /></svg>
                        </div>
                    </div>
                    <h2 class="text-xl font-bold text-slate-700 mt-8">看不见山高路远</h2>
                    <p class="mt-1">只专注于下一步。</p>
                </div>
            `
        };

        // 2. 任务卡片子组件
        const TaskCard = {
            props: ['task', 'isSwiped'],
            emits: ['start', 'edit', 'delete', 'swipe'],
            setup(props, { emit }) {
                const cardContent = ref(null);
                const pressProgress = ref(0);
                const isPressingEffect = ref(false); // FIX: For press-down animation
                let pressStartTime = 0;
                let animationFrameId = null;
                const LONG_PRESS_DURATION = 1000;

                const gesture = reactive({
                    startX: 0, startY: 0,
                    isSwiping: false,
                    isPressing: false,
                });

                const onPointerDown = (e) => {
                    if (e.button === 2) return;
                    gesture.startX = e.clientX || e.touches[0].clientX;
                    gesture.startY = e.clientY || e.touches[0].clientY;
                    gesture.isPressing = true;
                    isPressingEffect.value = true; // FIX: Apply pressing style
                    pressStartTime = Date.now();
                    
                    animationFrameId = requestAnimationFrame(updatePressProgress);

                    document.addEventListener('mousemove', onPointerMove);
                    document.addEventListener('mouseup', onPointerUp);
                    document.addEventListener('touchmove', onPointerMove, { passive: false });
                    document.addEventListener('touchend', onPointerUp);
                };

                const updatePressProgress = () => {
                    if (!gesture.isPressing) return;
                    const elapsed = Date.now() - pressStartTime;
                    const progress = Math.min(elapsed / LONG_PRESS_DURATION, 1);
                    pressProgress.value = progress * 100;

                    if (progress >= 1) {
                        emit('start', props.task.id);
                        resetGesture();
                    } else {
                        animationFrameId = requestAnimationFrame(updatePressProgress);
                    }
                };

                const onPointerMove = (e) => {
                    if (!gesture.isPressing) return;
                    
                    const currentX = e.clientX || e.touches[0].clientX;
                    const currentY = e.clientY || e.touches[0].clientY;
                    const diffX = currentX - gesture.startX;
                    const diffY = currentY - gesture.startY;

                    if (!gesture.isSwiping && Math.abs(diffX) < 10 && Math.abs(diffY) < 10) {
                        return;
                    }

                    cancelAnimationFrame(animationFrameId);
                    pressProgress.value = 0;
                    isPressingEffect.value = false; // FIX: Remove pressing style if moving

                    if (!gesture.isSwiping) {
                        if (Math.abs(diffX) > Math.abs(diffY)) {
                            gesture.isSwiping = true;
                            emit('swipe', props.task.id);
                        } else {
                            resetGesture();
                            return;
                        }
                    }
                    
                    if (gesture.isSwiping) {
                        e.preventDefault();
                        const newX = props.isSwiped ? -144 + diffX : diffX;
                        cardContent.value.style.transition = 'none';
                        cardContent.value.style.transform = `translateX(${Math.min(0, Math.max(-144, newX))}px)`;
                    }
                };

                const onPointerUp = (e) => {
                    if (gesture.isSwiping) {
                        const currentTransform = new DOMMatrix(getComputedStyle(cardContent.value).transform).m41;
                        cardContent.value.style.transition = 'transform 0.3s ease';
                        if (currentTransform < -72) {
                            cardContent.value.style.transform = 'translateX(-144px)';
                            emit('swipe', props.task.id);
                        } else {
                            cardContent.value.style.transform = 'translateX(0px)';
                            emit('swipe', null);
                        }
                    }
                    resetGesture();
                };

                const resetGesture = () => {
                    gesture.isPressing = false;
                    gesture.isSwiping = false;
                    isPressingEffect.value = false; // FIX: Always remove pressing style
                    pressProgress.value = 0;
                    cancelAnimationFrame(animationFrameId);
                    document.removeEventListener('mousemove', onPointerMove);
                    document.removeEventListener('mouseup', onPointerUp);
                    document.removeEventListener('touchmove', onPointerMove);
                    document.removeEventListener('touchend', onPointerUp);
                };
                
                watch(() => props.isSwiped, (isSwiped) => {
                    if (!isSwiped && cardContent.value) {
                        cardContent.value.style.transition = 'transform 0.3s ease';
                        cardContent.value.style.transform = 'translateX(0px)';
                    }
                });

                return { cardContent, pressProgress, isPressingEffect, onPointerDown };
            },
            template: `
                <div class="task-card-wrapper rounded-xl shadow-sm overflow-hidden" :class="{ 'is-swiped': isSwiped }">
                    <div class="task-card-actions">
                        <button @click="$emit('edit', task)" class="bg-indigo-500 text-white w-[72px] flex items-center justify-center">编辑</button>
                        <button @click="$emit('delete', task.id)" class="bg-rose-500 text-white w-[72px] flex items-center justify-center">删除</button>
                    </div>
                    <div 
                        ref="cardContent"
                        class="task-card-content p-4 border flex items-center justify-between"
                        :class="{ 'is-pressing': isPressingEffect }"
                        @mousedown="onPointerDown"
                        @touchstart="onPointerDown"
                    >
                        <div class="long-press-fill" :style="{ width: pressProgress + '%' }"></div>
                        <div class="relative z-10">
                            <span class="font-semibold text-slate-700">{{ task.name }}</span>
                            <p class="text-xs text-slate-400">{{ task.subtasks.length }} 个步骤</p>
                        </div>
                        <svg xmlns="http://www.w3.org/2000/svg" class="relative z-10 h-6 w-6 text-slate-400" fill="none" viewBox="0 0 24 24" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" /></svg>
                    </div>
                </div>
            `
        };

        // 3. 仪表盘主界面
        const DashboardScreen = {
            components: { TaskCard },
            props: ['tasks'],
            emits: ['create-task', 'start-task', 'edit-task', 'delete-task', 'update-order'],
            setup(props, { emit }) {
                const taskListEl = ref(null);
                const swipedCardId = ref(null);
                let sortable = null;

                const handleSwipe = (taskId) => {
                    swipedCardId.value = taskId;
                };

                const initSortable = () => {
                    if (sortable) sortable.destroy();
                    if (taskListEl.value) {
                         sortable = new Sortable(taskListEl.value, {
                            animation: 150,
                            ghostClass: 'sortable-ghost',
                            onEnd: (evt) => {
                                emit('update-order', { oldIndex: evt.oldIndex, newIndex: evt.newIndex });
                            }
                        });
                    }
                }
                
                const beforeEnter = (el) => {
                    el.style.opacity = 0;
                    el.style.transform = 'translateY(20px)';
                }
                const enter = (el, done) => {
                    const delay = el.dataset.index * 50;
                    setTimeout(() => {
                        el.style.transition = 'all 0.4s ease';
                        el.style.opacity = 1;
                        el.style.transform = 'translateY(0)';
                        done();
                    }, delay);
                }

                onMounted(initSortable);
                watch(() => props.tasks.length, () => {
                    nextTick(initSortable);
                });

                return { taskListEl, swipedCardId, handleSwipe, beforeEnter, enter };
            },
            template: `
                <div class="p-5 flex flex-col h-full">
                    <template v-if="tasks.length === 0">
                        <div class="h-full flex flex-col items-center justify-center text-center p-4 text-slate-500">
                             <h2 class="text-2xl font-bold text-slate-700 mt-8">你的任务列表是空的</h2>
                             <p class="mt-2 max-w-xs">点击下方的按钮来创建你的第一个任务流吧。</p>
                        </div>
                    </template>
                    <template v-else>
                        <header class="text-center pt-1 pb-4">
                            <h1 class="text-3xl font-black text-slate-800">任务隧道</h1>
                            <p class="text-slate-500 mt-2">一次只做一件事，轻松走向完成。</p>
                        </header>
                        <div ref="taskListEl" class="flex-grow overflow-y-auto px-2 space-y-3">
                            <transition-group @before-enter="beforeEnter" @enter="enter">
                                <task-card 
                                    v-for="(task, index) in tasks" 
                                    :key="task.id" 
                                    :data-index="index"
                                    :task="task"
                                    :is-swiped="swipedCardId === task.id"
                                    @start="$emit('start-task', $event)"
                                    @edit="$emit('edit-task', $event)"
                                    @delete="$emit('delete-task', $event)"
                                    @swipe="handleSwipe"
                                />
                            </transition-group>
                        </div>
                    </template>
                    <div class="p-4 mt-auto">
                        <button @click.stop="$emit('create-task')" class="w-full bg-indigo-600 text-white rounded-xl py-4 text-lg font-semibold flex items-center justify-center hover:bg-indigo-700 transition-colors shadow-lg" :class="{'breathing-button': tasks.length === 0}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2" fill="none" viewBox="0 0 24 24" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg>
                            创建新任务流
                        </button>
                    </div>
                </div>
            `
        };

        // 4. 任务编辑器界面
        const EditorScreen = {
            props: ['taskToEdit'],
            emits: ['save', 'back'],
            setup(props, { emit }) {
                const taskName = ref('');
                const subtasks = ref([]);
                const subtaskListEl = ref(null);
                let sortable = null;
                let nextSubId = 0;

                const editorTitle = computed(() => props.taskToEdit ? '编辑任务' : '新建任务');

                const initialize = () => {
                    nextSubId = 0;
                    if (props.taskToEdit) {
                        taskName.value = props.taskToEdit.name;
                        subtasks.value = JSON.parse(JSON.stringify(props.taskToEdit.subtasks)).map(sub => ({
                            ...sub,
                            id: `sub-${nextSubId++}`
                        }));
                    } else {
                        taskName.value = '';
                        subtasks.value = [];
                    }
                };
                
                onMounted(() => {
                    initialize();
                    sortable = new Sortable(subtaskListEl.value, {
                        animation: 150,
                        handle: '.drag-handle',
                        ghostClass: 'sortable-ghost',
                        onEnd: (evt) => {
                            const item = subtasks.value.splice(evt.oldIndex, 1)[0];
                            subtasks.value.splice(evt.newIndex, 0, item);
                        }
                    });
                });
                
                watch(() => props.taskToEdit, initialize);

                const addSubtask = async () => {
                    subtasks.value.push({ id: `sub-${nextSubId++}`, text: '' });
                    await nextTick();
                    const inputs = subtaskListEl.value.querySelectorAll('.edit-input');
                    const lastInput = inputs[inputs.length - 1];
                    if(lastInput) lastInput.focus();
                };

                const removeSubtask = (index) => {
                    subtasks.value.splice(index, 1);
                };

                const saveTask = () => {
                    if (!taskName.value.trim()) { alert('请为任务命名'); return; }
                    const finalSubtasks = subtasks.value
                        .filter(s => s.text.trim() !== '')
                        .map(s => ({ text: s.text }));

                    if (finalSubtasks.length === 0) { alert('请至少添加一个步骤'); return; }

                    const savedTask = {
                        id: props.taskToEdit ? props.taskToEdit.id : Date.now(),
                        name: taskName.value.trim(),
                        subtasks: finalSubtasks
                    };
                    emit('save', savedTask);
                };

                return { taskName, subtasks, editorTitle, addSubtask, removeSubtask, saveTask, subtaskListEl };
            },
            template: `
                <div class="p-5 flex flex-col h-full">
                    <header class="flex justify-between items-center mb-4">
                        <button @click="$emit('back')" class="text-slate-500 hover:text-slate-800">&larr; 返回</button>
                        <h2 class="text-xl font-bold text-slate-800">{{ editorTitle }}</h2>
                        <button @click="saveTask" class="bg-emerald-500 text-white px-4 py-1.5 rounded-full font-semibold hover:bg-emerald-600">完成</button>
                    </header>
                    <input type="text" v-model="taskName" placeholder="为任务命名" class="w-full p-3 mb-4 border-2 border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-600 focus:border-indigo-600">
                    <div class="flex-grow overflow-y-auto bg-slate-50 p-2 rounded-lg">
                        <div ref="subtaskListEl" class="space-y-2">
                            <transition-group name="stagger-list" tag="div">
                                <div v-for="(sub, index) in subtasks" :key="sub.id" class="subtask-item flex items-center bg-white p-2 rounded-md border">
                                    <span class="drag-handle text-slate-400 mr-3">☰</span>
                                    <input type="text" v-model="sub.text" class="edit-input flex-grow bg-white p-0 m-0 border-none focus:ring-0" placeholder="步骤描述...">
                                    <button @click="removeSubtask(index)" class="delete-subtask-btn text-rose-500 hover:text-rose-600 font-bold px-2 ml-2">×</button>
                                </div>
                            </transition-group>
                        </div>
                        <div @click="addSubtask" class="mt-2 flex items-center justify-center bg-transparent p-2 rounded-md border-2 border-dashed border-slate-300 hover:bg-slate-100 cursor-pointer">
                            <span class="text-slate-500 font-semibold">+ 添加步骤</span>
                        </div>
                    </div>
                </div>
            `
        };
        
        // 5. 准备开始界面
        const GetReadyScreen = {
            props: ['taskName'],
            emits: ['countdown-finished'],
            setup(props, { emit }) {
                const countdown = ref(3);
                const countdownText = computed(() => {
                    if (countdown.value > 0) return countdown.value;
                    if (countdown.value === 0) return 'Go!';
                    return '';
                });

                onMounted(() => {
                    const interval = setInterval(() => {
                        countdown.value--;
                        if (countdown.value < 0) {
                            clearInterval(interval);
                            emit('countdown-finished');
                        }
                    }, 400);
                });

                return { countdownText };
            },
            template: `
                <div class="p-5 flex flex-col h-full justify-center items-center text-center">
                    <div>
                        <p class="text-slate-500 mb-2">准备开始：</p>
                        <h2 class="text-4xl font-bold text-slate-800 mb-12">{{ taskName }}</h2>
                        <p class="text-9xl font-black text-indigo-600 countdown-pulse">{{ countdownText }}</p>
                    </div>
                </div>
            `
        };

        // 6. 专注模式界面
        const FocusScreen = {
            props: ['task'],
            emits: ['exit'],
            setup(props, { emit }) {
                const currentIndex = ref(0);
                const progressRing = ref(null);
                const progressBarEl = ref(null);
                const pressStartTime = ref(0);
                const sparkles = ref([]);
                let animationFrameId = null;
                
                const BASE_PRESS_DURATION = 800;
                const DURATION_INCREMENT = 200;

                const ICONS = {
                    NEXT: `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>`,
                    DONE: `<svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-emerald-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" /></svg>`
                };

                const currentSubtask = computed(() => props.task.subtasks[currentIndex.value]);
                const isLastStep = computed(() => currentIndex.value === props.task.subtasks.length - 1);
                const nextButtonIcon = computed(() => isLastStep.value ? ICONS.DONE : ICONS.NEXT);
                
                const currentPressDuration = computed(() => {
                    return BASE_PRESS_DURATION + (currentIndex.value * DURATION_INCREMENT);
                });

                const circumference = 2 * Math.PI * 46;

                const triggerSparkles = () => {
                    const newSparkles = [];
                    const colors = ['#fde047', '#67e8f9', '#f9a8d4', '#86efac'];
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 50 + 40;
                        newSparkles.push({
                            id: `sparkle-${Date.now()}-${i}`,
                            style: {
                                '--color': colors[Math.floor(Math.random() * colors.length)],
                                '--tx': `${Math.cos(angle) * distance}px`,
                                '--ty': `${Math.sin(angle) * distance}px`,
                            }
                        });
                    }
                    sparkles.value = newSparkles;
                };

                const resetRing = () => {
                    if (progressRing.value) {
                        progressRing.value.style.transition = 'stroke-dashoffset 0.3s ease-out';
                        progressRing.value.style.strokeDashoffset = circumference;
                        setTimeout(() => {
                            if(progressRing.value) progressRing.value.style.transition = 'stroke-dashoffset 0.1s linear';
                        }, 300);
                    }
                };

                const handleNextStep = () => {
                    triggerSparkles();
                    if (currentIndex.value >= props.task.subtasks.length - 1) {
                        emit('exit', true);
                        return;
                    }
                    currentIndex.value++;
                };

                const updateRing = () => {
                    const elapsed = Date.now() - pressStartTime.value;
                    const progress = Math.min(elapsed / currentPressDuration.value, 1);
                    const offset = circumference * (1 - progress);
                    if (progressRing.value) {
                        progressRing.value.style.strokeDashoffset = offset;
                    }
                    
                    if (progressBarEl.value) {
                        const segment = progressBarEl.value.children[currentIndex.value];
                        if (segment) {
                            const percentage = progress * 100;
                            segment.style.background = `linear-gradient(to right, #10b981 ${percentage}%, #e2e8f0 ${percentage}%)`;
                        }
                    }

                    if (progress >= 1) {
                        handleNextStep();
                        cancelAnimationFrame(animationFrameId);
                        resetRing();
                    } else {
                        animationFrameId = requestAnimationFrame(updateRing);
                    }
                };

                const startPress = (e) => {
                    e.preventDefault();
                    pressStartTime.value = Date.now();
                    animationFrameId = requestAnimationFrame(updateRing);
                };

                const endPress = (e) => {
                    e.preventDefault();
                    cancelAnimationFrame(animationFrameId);
                    
                    if (progressBarEl.value) {
                        const segment = progressBarEl.value.children[currentIndex.value];
                        if (segment) segment.style.background = '';
                    }
                    
                    resetRing();
                };

                const goToStep = (index) => {
                    if (index !== currentIndex.value) {
                        currentIndex.value = index;
                    }
                };
                
                onMounted(() => {
                    if (progressRing.value) {
                        progressRing.value.style.strokeDasharray = circumference;
                        progressRing.value.style.strokeDashoffset = circumference;
                    }
                });
                
                watch(currentIndex, (newIndex, oldIndex) => {
                    if (progressBarEl.value) {
                        const oldSegment = progressBarEl.value.children[oldIndex];
                        if (oldSegment) oldSegment.style.background = '';
                    }
                });

                return { currentIndex, currentSubtask, nextButtonIcon, progressRing, progressBarEl, sparkles, startPress, endPress, goToStep };
            },
            template: `
                <div class="p-5 flex flex-col h-full justify-between">
                    <header class="flex justify-start">
                         <button @click="$emit('exit', false)" class="text-slate-400 hover:text-slate-600">&larr; 退出</button>
                    </header>
                    <div class="flex-grow flex items-center justify-center overflow-hidden relative [transform-style:preserve-3d]">
                         <transition name="flip" mode="out-in">
                            <p :key="currentIndex" class="text-4xl font-bold text-center text-slate-800 break-words">{{ currentSubtask.text }}</p>
                         </transition>
                    </div>
                    <div class="w-full">
                        <div class="flex justify-center items-center mb-6">
                            <div class="relative w-24 h-24 transform active:scale-95 transition-transform" @mousedown="startPress" @mouseup="endPress" @mouseleave="endPress" @touchstart.prevent="startPress" @touchend.prevent="endPress">
                                <div class="absolute inset-0 flex items-center justify-center">
                                    <div v-for="sparkle in sparkles" :key="sparkle.id" class="sparkle" :style="sparkle.style"></div>
                                </div>
                                <svg class="absolute inset-0 w-full h-full" viewBox="0 0 100 100">
                                    <circle class="text-slate-200" stroke-width="8" stroke="currentColor" fill="transparent" r="46" cx="50" cy="50" />
                                    <circle ref="progressRing" class="text-emerald-500" stroke-width="8" stroke="currentColor" fill="transparent" r="46" cx="50" cy="50" stroke-linecap="round" transform="rotate(-90 50 50)" />
                                </svg>
                                <button class="w-20 h-20 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white rounded-full flex items-center justify-center shadow-lg border-4 border-slate-800" v-html="nextButtonIcon"></button>
                            </div>
                        </div>
                        <div ref="progressBarEl" class="w-full h-4 flex items-stretch gap-2">
                            <div 
                                v-for="(subtask, index) in task.subtasks" 
                                :key="index"
                                @click="goToStep(index)"
                                class="h-full rounded-md transition-all duration-500 cursor-pointer"
                                :class="index < currentIndex ? 'bg-emerald-500' : 'bg-slate-200'"
                                :style="{ flexGrow: 1 + index * 0.5 }"
                            ></div>
                        </div>
                    </div>
                </div>
            `
        };

        // 7. 全部完成界面
        const AllDoneScreen = {
            props: ['taskName'],
            emits: ['back-to-dash'],
            setup() {
                const confettis = ref([]);
                onMounted(() => {
                    const newConfettis = [];
                    const colors = ['#fde047', '#67e8f9', '#f9a8d4', '#86efac', '#fca5a5', '#a78bfa'];
                    for (let i = 0; i < 100; i++) {
                        newConfettis.push({
                            id: `confetti-${i}`,
                            style: {
                                '--color': colors[Math.floor(Math.random() * colors.length)],
                                '--duration': `${Math.random() * 2 + 3}s`,
                                '--delay': `${Math.random() * 1}s`,
                                left: `${Math.random() * 100}vw`,
                            }
                        });
                    }
                    confettis.value = newConfettis;
                });
                return { confettis };
            },
            template: `
                <div class="p-5 flex flex-col h-full justify-center items-center text-center overflow-hidden">
                    <div class="absolute inset-0 pointer-events-none">
                        <div v-for="c in confettis" :key="c.id" class="confetti" :style="c.style"></div>
                    </div>
                    <div class="all-done-content">
                        <svg class="checkmark" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
                            <circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
                            <path class="checkmark__check" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8"/>
                        </svg>
                        <p class="text-2xl text-slate-600 my-8">“{{ taskName }}” 已完成</p>
                        <button @click="$emit('back-to-dash')" class="bg-indigo-600 text-white px-8 py-4 rounded-lg font-bold text-lg hover:bg-indigo-700">返回主页</button>
                    </div>
                </div>
            `
        };
        
        // 8. 自定义确认弹窗
        const ConfirmModal = {
            props: ['visible', 'text'],
            emits: ['confirm', 'cancel'],
            template: `
                <transition name="spring-modal">
                    <div v-if="visible" class="absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
                        <div class="modal-box bg-white p-6 rounded-2xl w-[90%] max-w-xs text-center shadow-xl">
                            <p class="text-lg text-slate-800 mb-6">{{ text }}</p>
                            <div class="flex justify-center gap-4">
                                <button @click="$emit('cancel')" class="px-6 py-2 rounded-lg bg-slate-200 text-slate-700 hover:bg-slate-300">取消</button>
                                <button @click="$emit('confirm')" class="px-6 py-2 rounded-lg bg-rose-500 text-white hover:bg-rose-600">删除</button>
                            </div>
                        </div>
                    </div>
                </transition>
            `
        };


        // --- 根组件 (App) ---
        const App = {
            components: { SplashScreen, DashboardScreen, EditorScreen, GetReadyScreen, FocusScreen, AllDoneScreen, ConfirmModal },
            setup() {
                // --- State ---
                const tasks = ref([]);
                const currentView = ref('splash'); // splash, dashboard, editor, get-ready, focus, all-done
                const viewDirection = ref('forward'); // 'forward' or 'backward'
                const activeTask = ref(null); // The task being focused on or edited
                const confirmModalState = reactive({
                    visible: false,
                    text: '',
                    onConfirm: null
                });

                // --- Data Persistence ---
                const loadTasks = () => {
                    const tasksJSON = localStorage.getItem('adhdTasksVue');
                    tasks.value = tasksJSON ? JSON.parse(tasksJSON) : [];
                };
                const saveTasks = () => {
                    localStorage.setItem('adhdTasksVue', JSON.stringify(tasks.value));
                };
                
                onMounted(() => {
                    loadTasks();
                    const hasSeenSplash = sessionStorage.getItem('hasSeenSplashVue');
                    if (hasSeenSplash) {
                        currentView.value = 'dashboard';
                    }
                });

                // --- View Navigation ---
                const navigate = (view, direction = 'forward', task = null) => {
                    viewDirection.value = direction;
                    activeTask.value = task;
                    currentView.value = view;
                    if (view === 'dashboard' && !sessionStorage.getItem('hasSeenSplashVue')) {
                         sessionStorage.setItem('hasSeenSplashVue', 'true');
                    }
                };

                // --- Event Handlers ---
                const handleCreateTask = () => navigate('editor', 'forward');
                const handleEditTask = (task) => navigate('editor', 'forward', task);
                const handleSaveTask = (savedTask) => {
                    const index = tasks.value.findIndex(t => t.id === savedTask.id);
                    if (index > -1) {
                        tasks.value[index] = savedTask;
                    } else {
                        tasks.value.push(savedTask);
                    }
                    saveTasks();
                    navigate('dashboard', 'backward');
                };
                
                const showDeleteConfirm = (taskId) => {
                    confirmModalState.text = '你确定要永久删除这个任务吗？';
                    confirmModalState.onConfirm = () => {
                        tasks.value = tasks.value.filter(t => t.id !== taskId);
                        saveTasks();
                        confirmModalState.visible = false;
                    };
                    confirmModalState.visible = true;
                };

                const handleStartTask = (taskId) => {
                    const task = tasks.value.find(t => t.id === taskId);
                    if (task) navigate('get-ready', 'forward', task);
                };
                
                const handleFocusExit = (completed) => {
                    if (completed) {
                        navigate('all-done', 'forward', activeTask.value);
                    } else {
                        navigate('dashboard', 'backward');
                    }
                };

                const handleUpdateTaskOrder = ({ oldIndex, newIndex }) => {
                    const movedItem = tasks.value.splice(oldIndex, 1)[0];
                    tasks.value.splice(newIndex, 0, movedItem);
                    saveTasks();
                };

                return {
                    tasks,
                    currentView,
                    viewDirection,
                    activeTask,
                    confirmModalState,
                    navigate,
                    handleCreateTask,
                    handleEditTask,
                    handleSaveTask,
                    showDeleteConfirm,
                    handleStartTask,
                    handleFocusExit,
                    handleUpdateTaskOrder
                };
            },
            template: `
                <transition :name="'depth-' + viewDirection">
                    <component 
                        :is="currentView + '-screen'"
                        :key="currentView"
                        class="absolute inset-0"
                        :tasks="tasks"
                        :task="activeTask"
                        :taskToEdit="activeTask"
                        :taskName="activeTask?.name"
                        @enter="navigate('dashboard')"
                        @create-task="handleCreateTask"
                        @edit-task="handleEditTask"
                        @delete-task="showDeleteConfirm"
                        @save="handleSaveTask"
                        @back="navigate('dashboard', 'backward')"
                        @start-task="handleStartTask"
                        @countdown-finished="navigate('focus', 'forward', activeTask)"
                        @exit="handleFocusExit"
                        @back-to-dash="navigate('dashboard', 'backward')"
                        @update-order="handleUpdateTaskOrder"
                    />
                </transition>

                <confirm-modal
                    :visible="confirmModalState.visible"
                    :text="confirmModalState.text"
                    @confirm="confirmModalState.onConfirm"
                    @cancel="confirmModalState.visible = false"
                />
            `
        };

        // --- 创建并挂载应用 ---
        const app = createApp(App);
        app.component('splash-screen', SplashScreen);
        app.component('dashboard-screen', DashboardScreen);
        app.component('editor-screen', EditorScreen);
        app.component('get-ready-screen', GetReadyScreen);
        app.component('focus-screen', FocusScreen);
        app.component('all-done-screen', AllDoneScreen);
        app.mount('#app');

    </script>
</body>
</html>